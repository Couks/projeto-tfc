# API Client Patterns

## Overview

This rule defines patterns for using the centralized API client (`lib/api.ts`) to communicate with the NestJS backend. The API client handles HTTP requests, authentication, error handling, and type safety.

## Core Principles

- **Singleton Pattern**: Single API client instance across the app
- **Type Safety**: All requests and responses must be typed
- **Authentication**: Automatic cookie inclusion for session-based auth
- **Error Handling**: Consistent error handling and logging
- **Base URL**: Environment-based configuration
- **Credentials**: Always include cookies for authentication

## API Client Usage

### Basic Import and Usage

```typescript
import { apiClient } from '@/lib/api';
import { ResourceType, CreateResourceData } from '@/lib/types';

// GET request with type safety
const resources = await apiClient.get<ResourceType[]>('/api/resources');

// POST request with data
const newResource = await apiClient.post<ResourceType>('/api/resources', {
  name: 'New Resource',
  description: 'Resource description'
});

// PUT request for updates
const updatedResource = await apiClient.put<ResourceType>(`/api/resources/${id}`, {
  name: 'Updated Name'
});

// DELETE request
await apiClient.delete(`/api/resources/${id}`);
```

### In React Query Hooks

```typescript
import { useQuery, useMutation } from '@tanstack/react-query';
import { apiClient } from '@/lib/api';
import { queryKeys } from './queryKeys';
import { ResourceType, CreateResourceData } from '@/lib/types';

// Query hook
export function useResources() {
  return useQuery<ResourceType[]>({
    queryKey: queryKeys.resources.all,
    queryFn: () => apiClient.get<ResourceType[]>('/api/resources'),
    staleTime: 5 * 60 * 1000,
  });
}

// Mutation hook
export function useCreateResource() {
  return useMutation({
    mutationFn: (data: CreateResourceData) =>
      apiClient.post<ResourceType>('/api/resources', data),
    onSuccess: () => {
      // Handle success
    },
  });
}
```

## HTTP Methods

### GET Requests

```typescript
// Simple GET
const data = await apiClient.get<ResponseType>('/api/endpoint');

// GET with query parameters
const data = await apiClient.get<ResponseType>(
  `/api/resources?page=${page}&limit=${limit}`
);

// GET with custom headers
const data = await apiClient.get<ResponseType>('/api/endpoint', {
  headers: {
    'Custom-Header': 'value'
  }
});
```

### POST Requests

```typescript
// POST with data
const result = await apiClient.post<ResponseType>('/api/resources', {
  name: 'New Resource',
  description: 'Description'
});

// POST with FormData (for file uploads)
const formData = new FormData();
formData.append('file', file);
formData.append('name', 'filename');

const result = await apiClient.post<ResponseType>('/api/upload', formData, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
});
```

### PUT Requests

```typescript
// PUT for updates
const updated = await apiClient.put<ResourceType>(`/api/resources/${id}`, {
  name: 'Updated Name',
  description: 'Updated Description'
});

// PUT for partial updates
const patched = await apiClient.put<ResourceType>(`/api/resources/${id}`, {
  name: 'New Name Only'
});
```

### DELETE Requests

```typescript
// Simple DELETE
await apiClient.delete(`/api/resources/${id}`);

// DELETE with response
const result = await apiClient.delete<{ message: string }>(`/api/resources/${id}`);
console.log(result.message);
```

## Error Handling

### API Client Error Handling

```typescript
// The API client automatically throws errors for non-2xx responses
try {
  const data = await apiClient.get<ResourceType[]>('/api/resources');
  return data;
} catch (error) {
  // Error is already parsed from JSON response
  console.error('API request failed:', error.message);
  throw error; // Re-throw for React Query to handle
}
```

### Error Response Format

```typescript
// Backend error responses follow this format:
interface ApiError {
  message: string;
  statusCode: number;
  error?: string;
}

// Example error handling in components
export function ResourceList() {
  const { data, isLoading, error } = useResources();

  if (error) {
    return (
      <div className="text-red-600">
        Error: {error.message}
      </div>
    );
  }

  // ... rest of component
}
```

### Custom Error Handling

```typescript
// Custom error handling for specific cases
export async function createResourceWithRetry(data: CreateResourceData) {
  let lastError: Error;

  for (let attempt = 1; attempt <= 3; attempt++) {
    try {
      return await apiClient.post<ResourceType>('/api/resources', data);
    } catch (error) {
      lastError = error as Error;

      // Don't retry on client errors (4xx)
      if (error.message.includes('4')) {
        throw error;
      }

      // Wait before retry
      if (attempt < 3) {
        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
      }
    }
  }

  throw lastError!;
}
```

## Authentication

### Session-Based Authentication

```typescript
// The API client automatically includes cookies
// No need to manually add authentication headers

// Login request
const loginResult = await apiClient.post<{ user: User }>('/api/auth/login', {
  email: 'user@example.com',
  password: 'password'
});

// Subsequent requests automatically include session cookie
const userData = await apiClient.get<User>('/api/auth/me');
```

### Authentication Error Handling

```typescript
// Handle authentication errors
export async function fetchUserData() {
  try {
    return await apiClient.get<User>('/api/auth/me');
  } catch (error) {
    if (error.message.includes('401')) {
      // Redirect to login
      window.location.href = '/login';
      return null;
    }
    throw error;
  }
}
```

## Type Safety

### Request/Response Types

```typescript
// Define request types
interface CreateResourceRequest {
  name: string;
  description?: string;
  categoryId: string;
}

// Define response types
interface ResourceResponse {
  id: string;
  name: string;
  description: string;
  categoryId: string;
  createdAt: string;
  updatedAt: string;
}

// Use types in API calls
const resource = await apiClient.post<ResourceResponse>(
  '/api/resources',
  {
    name: 'New Resource',
    categoryId: 'cat-123'
  } satisfies CreateResourceRequest
);
```

### Generic Type Patterns

```typescript
// Generic API functions
async function fetchPaginatedData<T>(
  endpoint: string,
  page: number = 1,
  limit: number = 10
): Promise<{ data: T[]; total: number; page: number }> {
  return apiClient.get(`${endpoint}?page=${page}&limit=${limit}`);
}

// Usage
const resources = await fetchPaginatedData<ResourceType>('/api/resources', 1, 20);
```

## Configuration

### Environment Variables

```typescript
// lib/api.ts
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3001';

// Environment configuration
// .env.local
NEXT_PUBLIC_API_BASE_URL=https://api.matheuscastroks.com.br

// .env.development
NEXT_PUBLIC_API_BASE_URL=http://localhost:3001
```

### Custom Configuration

```typescript
// Custom API client with different configuration
class CustomApiClient extends ApiClient {
  constructor(baseUrl: string, private customHeaders: Record<string, string>) {
    super(baseUrl);
  }

  async get<T>(path: string, options?: RequestInit): Promise<T> {
    return super.get<T>(path, {
      ...options,
      headers: {
        ...this.customHeaders,
        ...options?.headers,
      },
    });
  }
}

// Usage
const customClient = new CustomApiClient(API_BASE_URL, {
  'X-Custom-Header': 'value'
});
```

## Request/Response Interceptors

### Request Interceptor Pattern

```typescript
// Add request logging
class LoggingApiClient extends ApiClient {
  async get<T>(path: string, options?: RequestInit): Promise<T> {
    console.log(`[API] GET ${path}`);
    const start = Date.now();

    try {
      const result = await super.get<T>(path, options);
      console.log(`[API] GET ${path} - ${Date.now() - start}ms`);
      return result;
    } catch (error) {
      console.error(`[API] GET ${path} - ERROR:`, error);
      throw error;
    }
  }
}
```

### Response Interceptor Pattern

```typescript
// Add response transformation
class TransformingApiClient extends ApiClient {
  async get<T>(path: string, options?: RequestInit): Promise<T> {
    const response = await super.get<T>(path, options);

    // Transform response if needed
    if (path.includes('/api/resources')) {
      return this.transformResourceResponse(response as any) as T;
    }

    return response;
  }

  private transformResourceResponse(response: any) {
    // Add computed fields, transform dates, etc.
    return {
      ...response,
      displayName: response.name.toUpperCase(),
      createdAt: new Date(response.createdAt),
    };
  }
}
```

## Best Practices

### Do's

- ✅ Always type API requests and responses
- ✅ Use the singleton `apiClient` instance
- ✅ Handle errors appropriately
- ✅ Use React Query for data fetching
- ✅ Include proper error messages
- ✅ Use environment variables for base URL
- ✅ Log API errors for debugging

### Don'ts

- ❌ Don't create multiple API client instances
- ❌ Don't use `any` types for API responses
- ❌ Don't ignore error handling
- ❌ Don't hardcode API URLs
- ❌ Don't forget to include credentials
- ❌ Don't make direct fetch calls (use apiClient)

## Common Patterns

### File Upload

```typescript
export async function uploadFile(file: File, resourceId: string) {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('resourceId', resourceId);

  return apiClient.post<{ fileId: string; url: string }>('/api/upload', formData, {
    headers: {
      'Content-Type': 'multipart/form-data'
    }
  });
}
```

### Batch Operations

```typescript
export async function batchDeleteResources(ids: string[]) {
  return apiClient.post<{ deletedCount: number }>('/api/resources/batch-delete', {
    ids
  });
}
```

### Search with Filters

```typescript
interface SearchFilters {
  query?: string;
  category?: string;
  dateFrom?: string;
  dateTo?: string;
  page?: number;
  limit?: number;
}

export async function searchResources(filters: SearchFilters) {
  const params = new URLSearchParams();

  Object.entries(filters).forEach(([key, value]) => {
    if (value !== undefined && value !== null) {
      params.append(key, String(value));
    }
  });

  return apiClient.get<ResourceType[]>(`/api/resources/search?${params}`);
}
```

### Real-time Updates

```typescript
// For WebSocket connections (if needed)
export class RealtimeApiClient {
  private ws: WebSocket | null = null;

  connect(resourceId: string, onUpdate: (data: any) => void) {
    this.ws = new WebSocket(`ws://localhost:3001/api/resources/${resourceId}/ws`);

    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      onUpdate(data);
    };
  }

  disconnect() {
    this.ws?.close();
    this.ws = null;
  }
}
```

## Testing

### Mock API Client

```typescript
// For testing
export class MockApiClient {
  private responses = new Map<string, any>();

  mockGet<T>(path: string, response: T) {
    this.responses.set(`GET:${path}`, response);
  }

  async get<T>(path: string): Promise<T> {
    const response = this.responses.get(`GET:${path}`);
    if (!response) {
      throw new Error(`No mock response for GET:${path}`);
    }
    return response;
  }
}

// Usage in tests
const mockClient = new MockApiClient();
mockClient.mockGet('/api/resources', [
  { id: '1', name: 'Resource 1' },
  { id: '2', name: 'Resource 2' }
]);
```

## Auto-Attach Rules

This rule applies to:
- `src/lib/api.ts` - API client implementation
- `src/lib/hooks/**/*.ts` - Hooks using API client
- `src/**/*Client.tsx` - Client components making API calls
- `src/app/**/page.tsx` - Pages with server-side API calls

## Related Rules

- `react-query.mdc` - React Query patterns
- `frontend-types.mdc` - TypeScript type organization
- `authentication-security.mdc` - Authentication patterns
