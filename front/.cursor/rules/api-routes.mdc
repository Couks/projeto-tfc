---
description: API route standards and best practices
globs:
  - src/app/api/**/*.ts
alwaysApply: false
---

# API Routes Standards

## Route Organization

### File Structure
API routes follow Next.js App Router conventions:

```
app/api/
  auth/
    login/route.ts
    logout/route.ts
    register/route.ts
  sites/
    route.ts              # GET /api/sites, POST /api/sites
    [id]/
      route.ts            # GET /api/sites/:id, PUT/DELETE /api/sites/:id
      domains/route.ts    # GET /api/sites/:id/domains
```

### HTTP Methods
Each route file exports named functions for HTTP methods:

```typescript
// GET /api/users
export async function GET(req: Request) {
  // Handle GET request
}

// POST /api/users
export async function POST(req: Request) {
  // Handle POST request
}

// PUT /api/users/:id
export async function PUT(req: Request, { params }: { params: { id: string } }) {
  // Handle PUT request
}

// DELETE /api/users/:id
export async function DELETE(req: Request, { params }: { params: { id: string } }) {
  // Handle DELETE request
}
```

## Route Handler Structure

### Standard Pattern
Follow this structure for all route handlers:

```typescript
import { NextResponse } from 'next/server';
import { z } from 'zod';
import { prisma } from '@/lib/db';
import { getSession } from '@/lib/auth';

// 1. Runtime configuration (if needed)
export const runtime = 'nodejs'; // or 'edge'

// 2. Validation schemas
const requestSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

// 3. Handler function
export async function POST(req: Request) {
  try {
    // Authentication check
    const session = await getSession();
    if (!session) {
      return NextResponse.json(
        { error: 'unauthorized' },
        { status: 401 }
      );
    }

    // Request body parsing and validation
    const body = await req.json().catch(() => null);
    const parsed = requestSchema.safeParse(body);

    if (!parsed.success) {
      return NextResponse.json(
        { error: 'invalid_body', details: parsed.error.errors },
        { status: 400 }
      );
    }

    const { name, email } = parsed.data;

    // Business logic
    const result = await prisma.user.create({
      data: { name, email, userId: session.userId },
    });

    // Success response
    return NextResponse.json({
      id: result.id,
      name: result.name,
    });

  } catch (error) {
    console.error('[API][POST /api/users]', error);
    return NextResponse.json(
      { error: 'internal_server_error' },
      { status: 500 }
    );
  }
}
```

## Request Validation

### Using Zod
Always validate request data with Zod schemas:

```typescript
// Define schema
const createUserSchema = z.object({
  email: z.string().trim().toLowerCase().email(),
  password: z.string().min(8).max(100),
  name: z.string().min(2).max(100).optional(),
});

// Validate
const parsed = createUserSchema.safeParse(await req.json().catch(() => ({})));

if (!parsed.success) {
  return NextResponse.json(
    { error: 'invalid_body', details: parsed.error.errors },
    { status: 400 }
  );
}

// Use validated data
const { email, password, name } = parsed.data;
```

### Query Parameters
Validate URL query parameters:

```typescript
export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const page = searchParams.get('page');
  const limit = searchParams.get('limit');

  const querySchema = z.object({
    page: z.coerce.number().int().min(1).default(1),
    limit: z.coerce.number().int().min(1).max(100).default(20),
  });

  const params = querySchema.safeParse({ page, limit });

  if (!params.success) {
    return NextResponse.json(
      { error: 'invalid_query_params' },
      { status: 400 }
    );
  }

  // Use validated params
  const { page: validPage, limit: validLimit } = params.data;
}
```

### Route Parameters
Access and validate dynamic route parameters:

```typescript
export async function GET(
  req: Request,
  { params }: { params: { id: string; slug: string } }
) {
  const paramSchema = z.object({
    id: z.string().cuid(),
    slug: z.string().min(1),
  });

  const validated = paramSchema.safeParse(params);

  if (!validated.success) {
    return NextResponse.json(
      { error: 'invalid_params' },
      { status: 400 }
    );
  }

  const { id, slug } = validated.data;
}
```

## Authentication & Authorization

### Session Verification
Check authentication for protected routes:

```typescript
import { getSession } from '@/lib/auth';

export async function GET(req: Request) {
  const session = await getSession();

  if (!session) {
    return NextResponse.json(
      { error: 'unauthorized' },
      { status: 401 }
    );
  }

  // Use session.userId
  const userId = session.userId;
}
```

### Resource Authorization
Verify user owns the resource:

```typescript
export async function DELETE(
  req: Request,
  { params }: { params: { id: string } }
) {
  const session = await getSession();
  if (!session) {
    return NextResponse.json({ error: 'unauthorized' }, { status: 401 });
  }

  const resource = await prisma.site.findUnique({
    where: { id: params.id },
  });

  if (!resource) {
    return NextResponse.json({ error: 'not_found' }, { status: 404 });
  }

  if (resource.userId !== session.userId) {
    return NextResponse.json({ error: 'forbidden' }, { status: 403 });
  }

  // Proceed with deletion
  await prisma.site.delete({ where: { id: params.id } });

  return NextResponse.json({ success: true });
}
```

## Response Standards

### HTTP Status Codes
Use appropriate status codes:

- **200 OK**: Successful GET, PUT, PATCH
- **201 Created**: Successful POST (resource created)
- **204 No Content**: Successful DELETE
- **400 Bad Request**: Invalid request data
- **401 Unauthorized**: Missing or invalid authentication
- **403 Forbidden**: Authenticated but not authorized
- **404 Not Found**: Resource doesn't exist
- **409 Conflict**: Resource already exists
- **422 Unprocessable Entity**: Validation failed
- **500 Internal Server Error**: Server error

### Response Format
Use consistent JSON response format:

```typescript
// Success response
return NextResponse.json({
  id: user.id,
  name: user.name,
  email: user.email,
});

// Error response (single error)
return NextResponse.json(
  { error: 'resource_not_found' },
  { status: 404 }
);

// Error response (with details)
return NextResponse.json(
  {
    error: 'validation_error',
    details: parsed.error.errors
  },
  { status: 400 }
);

// Success with metadata
return NextResponse.json({
  data: users,
  pagination: {
    page: 1,
    limit: 20,
    total: 100,
  },
});
```

### Setting Headers
Set appropriate response headers:

```typescript
const response = NextResponse.json({ data });

// CORS
response.headers.set('Access-Control-Allow-Origin', '*');

// Caching
response.headers.set('Cache-Control', 'public, max-age=3600');

// Security
response.headers.set('X-Content-Type-Options', 'nosniff');

// Cookies
response.cookies.set('session', signedValue, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax',
  path: '/',
});

return response;
```

## Error Handling

### Try-Catch Blocks
Wrap async operations in try-catch:

```typescript
export async function POST(req: Request) {
  try {
    const data = await performOperation();
    return NextResponse.json({ data });
  } catch (error) {
    console.error('[API][POST /api/endpoint]', error);

    // Handle specific errors
    if (error instanceof PrismaClientKnownRequestError) {
      if (error.code === 'P2002') {
        return NextResponse.json(
          { error: 'resource_already_exists' },
          { status: 409 }
        );
      }
    }

    return NextResponse.json(
      { error: 'internal_server_error' },
      { status: 500 }
    );
  }
}
```

### Error Logging
Log errors with context:

```typescript
console.error('[API][POST /api/users]', {
  error,
  userId: session?.userId,
  timestamp: new Date().toISOString(),
});
```

## Database Operations

### Prisma Best Practices
Follow these patterns for database access:

```typescript
// Single record
const user = await prisma.user.findUnique({
  where: { id: userId },
  select: {
    id: true,
    name: true,
    email: true,
    // Don't select passwordHash unless needed
  },
});

// Multiple records with pagination
const sites = await prisma.site.findMany({
  where: { userId: session.userId },
  include: {
    domains: true,
    _count: { select: { settings: true } },
  },
  orderBy: { createdAt: 'desc' },
  skip: (page - 1) * limit,
  take: limit,
});

// Create with relations
const site = await prisma.site.create({
  data: {
    name,
    userId: session.userId,
    siteKey: generateSiteKey(),
    domains: {
      create: { host: domain, isPrimary: true },
    },
  },
  include: {
    domains: true,
  },
});

// Update
const updated = await prisma.user.update({
  where: { id: userId },
  data: { name: newName },
});

// Delete
await prisma.site.delete({
  where: { id: siteId },
});
```

### Transactions
Use transactions for multiple related operations:

```typescript
const result = await prisma.$transaction(async (tx) => {
  const user = await tx.user.create({
    data: { email, name },
  });

  const site = await tx.site.create({
    data: {
      userId: user.id,
      name: 'Default Site',
      siteKey: generateSiteKey(),
    },
  });

  return { user, site };
});
```

## Performance Considerations

### Caching
Control caching behavior:

```typescript
// No caching (dynamic data)
export async function GET(req: Request) {
  const data = await fetch('https://api.example.com', {
    cache: 'no-store',
  });
}

// Revalidate every 60 seconds
export const revalidate = 60;

// Static (never revalidates)
export const dynamic = 'force-static';
```

### Database Query Optimization
- Select only needed fields
- Use `include` sparingly
- Implement pagination for lists
- Create appropriate database indexes
- Use `_count` for counting relations

```typescript
// Good: Select specific fields
const users = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    email: true,
  },
});

// Avoid: Select all fields
const users = await prisma.user.findMany();
```

## Rate Limiting & Security

### Input Sanitization
Validate and sanitize all inputs:

```typescript
const schema = z.object({
  name: z.string().trim().min(1).max(100),
  email: z.string().trim().toLowerCase().email(),
  url: z.string().url().max(500),
});
```

### CORS Configuration
Set appropriate CORS headers:

```typescript
export async function OPTIONS(req: Request) {
  return new NextResponse(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': process.env.ALLOWED_ORIGIN || '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}
```

## Logging

### Console Logging
Use structured logging with context:

```typescript
// Info
console.log('[API][GET /api/sites]', {
  userId: session.userId,
  count: sites.length,
});

// Warning
console.warn('[API][POST /api/sites] Domain validation warning', {
  domain,
  reason: 'TLD not recognized',
});

// Error
console.error('[API][DELETE /api/sites] Failed to delete', {
  siteId,
  error: error.message,
});
```

### Log Levels
- Use `console.log` for informational messages
- Use `console.warn` for warnings and deprecated features
- Use `console.error` for errors and exceptions
- Include relevant context in all logs
- Use consistent format: `[Component][Action] message`
