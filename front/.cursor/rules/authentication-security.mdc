# Authentication & Security Standards

## Overview

This rule defines patterns for authentication and security in the frontend application. The system uses session-based authentication with HMAC-signed cookies, communicating with a NestJS backend for all authentication operations.

## Authentication Architecture

### Session-Based Authentication
- **Frontend**: Validates session cookies in middleware
- **Backend**: Handles login/logout and session creation
- **Cookies**: HMAC-SHA256 signed session cookies
- **Format**: `{userId:string}.signature`
- **Storage**: HttpOnly cookies (handled by backend)

### Authentication Flow
1. User submits login form
2. Frontend sends credentials to backend `/api/auth/login`
3. Backend validates credentials and creates session cookie
4. Frontend middleware validates session cookie on protected routes
5. Frontend uses `useUser()` hook to get current user data

## Session Cookie Management

### Cookie Verification (Frontend)

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

/**
 * Verifies HMAC-signed session cookie
 * Uses Web Crypto API compatible with Edge Runtime
 */
async function verifySignedCookie(signed: string): Promise<{ userId: string } | null> {
  if (!signed) return null;

  try {
    // Find the last '.' that separates data from signature
    const lastDot = signed.lastIndexOf(".");
    if (lastDot <= 0) return null;

    // Separate data (before .) and signature (after .)
    const raw = signed.slice(0, lastDot);
    const sig = signed.slice(lastDot + 1);

    // Create HMAC key using Web Crypto API
    const key = await crypto.subtle.importKey(
      "raw",
      new TextEncoder().encode(getSecret()),
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign", "verify"]
    );

    // Generate HMAC-SHA256 signature of data
    const signature = await crypto.subtle.sign(
      "HMAC",
      key,
      new TextEncoder().encode(raw)
    );
    const expectedSig = Array.from(new Uint8Array(signature))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");

    // Compare signatures using constant-time comparison
    const isValid = await crypto.subtle.verify(
      "HMAC",
      key,
      new Uint8Array(signature),
      new TextEncoder().encode(raw)
    );

    if (!isValid) return null;

    // If signature valid, decode JSON
    const parsed = JSON.parse(raw) as { userId: string };
    // Validate data structure
    if (!parsed?.userId || typeof parsed.userId !== "string") {
      return null;
    }

    return parsed;
  } catch {
    // Any verification error returns null
    return null;
  }
}

function getSecret(): string {
  const s = process.env.NEXTAUTH_SECRET || "";
  if (!s) return "dev-secret-do-not-use-in-prod";
  return s;
}
```

### Middleware Implementation

```typescript
// middleware.ts
export async function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;

  // Allow all public paths
  if (isPublicPath(pathname)) {
    return NextResponse.next();
  }

  // Require auth for protected paths
  if (isProtectedPath(pathname)) {
    const hasValidSession = await hasValidSessionCookie(req);
    if (!hasValidSession) {
      console.warn("[Middleware] blocked unauthenticated access", {
        pathname,
        cookies: req.cookies.getAll().map((c) => ({
          name: c.name,
          value: c.value?.substring(0, 20) + "...",
        })),
      });
      const url = new URL("/login", req.url);
      return NextResponse.redirect(url);
    }
    console.log("[Middleware] allowed", { pathname });
    return NextResponse.next();
  }

  // Default allow
  return NextResponse.next();
}

async function hasValidSessionCookie(req: NextRequest): Promise<boolean> {
  const c = req.cookies.get("admin_session");
  return !!(await verifySignedCookie(c?.value || ""));
}

// Path configuration
const PUBLIC_PATHS: Array<(p: string) => boolean> = [
  (p) => p === "/",
  (p) => p === "/login",
  (p) => p === "/register",
];

const PROTECTED_PATHS: Array<(p: string) => boolean> = [
  (p) => p.startsWith("/admin"),
  (p) => p.startsWith("/api/sites"),
];

function isPublicPath(pathname: string): boolean {
  return PUBLIC_PATHS.some((fn) => fn(pathname));
}

function isProtectedPath(pathname: string): boolean {
  return PROTECTED_PATHS.some((fn) => fn(pathname));
}
```

## Authentication Hooks

### User Hook

```typescript
// lib/hooks/useAuth.ts
import { useQuery } from '@tanstack/react-query';
import { queryKeys } from './queryKeys';
import { apiClient } from '../api';
import { User } from '../types';

export interface LoginData {
  email: string;
  password: string;
}

export interface RegisterData {
  email: string;
  password: string;
  name: string;
}

// Query to get current user
export function useUser() {
  return useQuery<User>({
    queryKey: queryKeys.auth.me(),
    queryFn: async () => {
      return apiClient.get<User>("/api/auth/me");
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
    retry: false, // Don't retry on 401
  });
}

// Mutation for login
export function useLogin() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: LoginData) => {
      return apiClient.post<{ user: User; message: string }>("/api/auth/login", data);
    },
    onSuccess: () => {
      // Invalidate user query to refetch
      queryClient.invalidateQueries({ queryKey: queryKeys.auth.me() });
    },
  });
}

// Mutation for logout
export function useLogout() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async () => {
      return apiClient.post("/api/auth/logout");
    },
    onSuccess: () => {
      // Clear all queries
      queryClient.clear();
      // Redirect to login
      window.location.href = '/login';
    },
  });
}

// Mutation for register
export function useRegister() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: RegisterData) => {
      return apiClient.post<{ user: User; message: string }>("/api/auth/register", data);
    },
    onSuccess: () => {
      // Invalidate user query to refetch
      queryClient.invalidateQueries({ queryKey: queryKeys.auth.me() });
    },
  });
}
```

## Component Patterns

### Login Form

```typescript
'use client';

import { useState } from 'react';
import { useLogin } from '@/lib/hooks';
import { Button } from '@ui/button';
import { Input } from '@ui/input';
import { Card, CardHeader, CardTitle, CardContent } from '@ui/card';

export function LoginForm() {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
  });

  const loginMutation = useLogin();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      await loginMutation.mutateAsync(formData);
      // Redirect handled by mutation success
    } catch (error) {
      console.error('Login failed:', error);
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData(prev => ({
      ...prev,
      [e.target.name]: e.target.value,
    }));
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Login</CardTitle>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          <Input
            name="email"
            type="email"
            placeholder="Email"
            value={formData.email}
            onChange={handleChange}
            required
          />
          <Input
            name="password"
            type="password"
            placeholder="Password"
            value={formData.password}
            onChange={handleChange}
            required
          />
          <Button
            type="submit"
            disabled={loginMutation.isPending}
            className="w-full"
          >
            {loginMutation.isPending ? 'Logging in...' : 'Login'}
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}
```

### Protected Route Component

```typescript
'use client';

import { useUser } from '@/lib/hooks';
import { Skeleton } from '@ui/skeleton';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

interface ProtectedRouteProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

export function ProtectedRoute({ children, fallback }: ProtectedRouteProps) {
  const { data: user, isLoading, error } = useUser();
  const router = useRouter();

  useEffect(() => {
    if (error && !isLoading) {
      router.push('/login');
    }
  }, [error, isLoading, router]);

  if (isLoading) {
    return fallback || <Skeleton className="h-32 w-full" />;
  }

  if (error || !user) {
    return null; // Will redirect to login
  }

  return <>{children}</>;
}
```

### User Profile Component

```typescript
'use client';

import { useUser, useLogout } from '@/lib/hooks';
import { Button } from '@ui/button';
import { Card, CardHeader, CardTitle, CardContent } from '@ui/card';
import { Skeleton } from '@ui/skeleton';

export function UserProfile() {
  const { data: user, isLoading } = useUser();
  const logoutMutation = useLogout();

  const handleLogout = () => {
    logoutMutation.mutate();
  };

  if (isLoading) {
    return <Skeleton className="h-32 w-full" />;
  }

  if (!user) {
    return null;
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Profile</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div>
          <p className="text-sm text-muted-foreground">Name</p>
          <p className="font-medium">{user.name}</p>
        </div>
        <div>
          <p className="text-sm text-muted-foreground">Email</p>
          <p className="font-medium">{user.email}</p>
        </div>
        <Button
          onClick={handleLogout}
          variant="destructive"
          disabled={logoutMutation.isPending}
        >
          {logoutMutation.isPending ? 'Logging out...' : 'Logout'}
        </Button>
      </CardContent>
    </Card>
  );
}
```

## API Client Configuration

### Credentials Inclusion

```typescript
// lib/api.ts
class ApiClient {
  async get<T>(path: string, options?: RequestInit): Promise<T> {
    const response = await fetch(`${this.baseUrl}${path}`, {
      ...options,
      method: 'GET',
      credentials: 'include', // Include cookies for session
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
      },
    });

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`);
    }

    return response.json();
  }

  async post<T>(path: string, data?: any, options?: RequestInit): Promise<T> {
    const response = await fetch(`${this.baseUrl}${path}`, {
      ...options,
      method: 'POST',
      credentials: 'include', // Include cookies for session
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
      },
      body: data ? JSON.stringify(data) : undefined,
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        errorData.message || `API request failed: ${response.statusText}`,
      );
    }

    return response.json();
  }
}
```

## Security Best Practices

### Frontend Security

- **Never store sensitive data in localStorage/sessionStorage**
- **Always include credentials in API calls**
- **Validate session cookies in middleware**
- **Use HTTPS in production**
- **Implement proper error handling**
- **Don't expose internal errors to users**

### Authentication Security

- **HMAC-SHA256 signed cookies**
- **Constant-time comparison for signature verification**
- **Session expiration handling**
- **Proper logout with cookie clearing**
- **CSRF protection via same-origin policy**

### Route Protection

```typescript
// Path configuration for middleware
const PUBLIC_PATHS = [
  (p: string) => p === "/",
  (p: string) => p === "/login",
  (p: string) => p === "/register",
];

const PROTECTED_PATHS = [
  (p: string) => p.startsWith("/admin"),
  (p: string) => p.startsWith("/api/sites"),
];

// Exclude Next.js internals from middleware
export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp|ico)$).*)",
  ],
};
```

## Error Handling

### Authentication Errors

```typescript
// Handle authentication errors in components
export function AuthErrorHandler({ error }: { error: Error }) {
  if (error.message.includes('401')) {
    return (
      <div className="text-red-600">
        Session expired. Please log in again.
      </div>
    );
  }

  if (error.message.includes('403')) {
    return (
      <div className="text-red-600">
        You don't have permission to access this resource.
      </div>
    );
  }

  return (
    <div className="text-red-600">
      Authentication error: {error.message}
    </div>
  );
}
```

### API Error Handling

```typescript
// Centralized error handling in API client
class ApiClient {
  private async handleResponse<T>(response: Response): Promise<T> {
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));

      // Handle authentication errors
      if (response.status === 401) {
        // Redirect to login
        window.location.href = '/login';
        throw new Error('Unauthorized');
      }

      throw new Error(
        errorData.message || `API request failed: ${response.statusText}`,
      );
    }

    return response.json();
  }
}
```

## Environment Variables

### Required Environment Variables

```bash
# Frontend (.env.local)
NEXT_PUBLIC_API_BASE_URL=http://localhost:3001
NEXTAUTH_SECRET=your-secret-key-here

# Backend (.env)
NEXTAUTH_SECRET=your-secret-key-here
DATABASE_URL=postgresql://...
FRONTEND_URL=http://localhost:3000
```

### Environment Configuration

```typescript
// lib/config.ts
export const config = {
  apiBaseUrl: process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3001',
  authSecret: process.env.NEXTAUTH_SECRET || 'dev-secret-do-not-use-in-prod',
  isProduction: process.env.NODE_ENV === 'production',
};
```

## Testing Authentication

### Mock Authentication

```typescript
// For testing
export function mockAuth() {
  // Mock user data
  const mockUser: User = {
    id: '1',
    email: 'test@example.com',
    name: 'Test User',
    createdAt: new Date().toISOString(),
  };

  // Mock API responses
  jest.mock('@/lib/api', () => ({
    apiClient: {
      get: jest.fn().mockResolvedValue(mockUser),
      post: jest.fn().mockResolvedValue({ user: mockUser, message: 'Success' }),
    },
  }));
}
```

### Test Authentication Flow

```typescript
// Authentication flow tests
describe('Authentication', () => {
  it('should redirect to login when not authenticated', async () => {
    // Mock unauthenticated state
    jest.mocked(apiClient.get).mockRejectedValue(new Error('401'));

    render(<ProtectedRoute><div>Protected Content</div></ProtectedRoute>);

    // Should redirect to login
    expect(mockRouter.push).toHaveBeenCalledWith('/login');
  });

  it('should display user profile when authenticated', async () => {
    const mockUser = { id: '1', name: 'Test User', email: 'test@example.com' };
    jest.mocked(apiClient.get).mockResolvedValue(mockUser);

    render(<UserProfile />);

    await waitFor(() => {
      expect(screen.getByText('Test User')).toBeInTheDocument();
    });
  });
});
```

## Auto-Attach Rules

This rule applies to:
- `src/middleware.ts` - Authentication middleware
- `src/lib/hooks/useAuth.ts` - Authentication hooks
- `src/app/(auth)/**/*.tsx` - Authentication pages
- `src/app/(admin)/**/*.tsx` - Protected admin pages

## Related Rules

- `api-client.mdc` - API client patterns
- `react-query.mdc` - React Query patterns
- `frontend-types.mdc` - TypeScript type organization
